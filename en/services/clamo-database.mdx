---
title: clamo-database
description: Esquemas Prisma, migraciones y utilidades para bases de datos multi-tenant
---

# clamo-database

Paquete central que define los esquemas de base de datos, migraciones y utilidades para el modelo multi-tenant de Clamo.

## Información General

| Propiedad | Valor |
|-----------|-------|
| **Repositorio** | `GetClamo/clamo-database` |
| **Lenguaje** | TypeScript |
| **ORM** | Prisma |
| **Base de Datos** | Neon PostgreSQL |

## Arquitectura de Bases de Datos

Clamo utiliza un modelo de **database-per-tenant** con dos tipos de bases de datos:

```mermaid
flowchart TB
    subgraph Control [Base de Datos de Control]
        Companies[Companies]
        Users[Users]
        CompanyDB[CompanyDatabase]
        Plans[Plans]
    end
    
    subgraph Tenant1 [Tenant DB - Empresa A]
        Cases1[Cases]
        Movements1[Movements]
        Entities1[MonitoredEntities]
    end
    
    subgraph Tenant2 [Tenant DB - Empresa B]
        Cases2[Cases]
        Movements2[Movements]
        Entities2[MonitoredEntities]
    end
    
    CompanyDB -->|neonBranchId| Tenant1
    CompanyDB -->|neonBranchId| Tenant2
```

## Esquemas

### Control Schema

El esquema de control maneja la información global de la plataforma:

```prisma
// prisma/control/schema.prisma

model Company {
  id              String   @id @default(cuid())
  workosOrgId     String   @unique
  name            String
  ruc             String?
  parentId        String?
  plan            Plan     @default(free)
  settings        Json     @default("{}")
  metadata        Json     @default("{}")
  databaseStatus  DatabaseStatus @default(pending)
  ownerEmail      String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  parent          Company?  @relation("CompanyHierarchy", fields: [parentId], references: [id])
  children        Company[] @relation("CompanyHierarchy")
  users           User[]
  database        CompanyDatabase?
}

model User {
  id              String   @id @default(cuid())
  workosUserId    String   @unique
  email           String
  firstName       String?
  lastName        String?
  companyId       String
  role            Role     @default(member)
  onboardingState OnboardingState @default(pending_onboarding)
  createdAt       DateTime @default(now())
  
  company         Company  @relation(fields: [companyId], references: [id])
}

model CompanyDatabase {
  id                  String   @id @default(cuid())
  companyId           String   @unique
  neonProjectId       String
  neonBranchId        String
  neonEndpointId      String?
  databaseName        String
  databaseHost        String
  databaseUser        String
  pooledConnSecretId  String   // ID en Supabase Vault
  directConnSecretId  String   // ID en Supabase Vault
  status              DbStatus @default(active)
  
  company             Company  @relation(fields: [companyId], references: [id])
}

enum Plan {
  free
  pro
  enterprise
}

enum DatabaseStatus {
  pending
  provisioning
  ready
  failed
}

enum Role {
  admin
  member
}

enum OnboardingState {
  pending_onboarding
  completed
}

enum DbStatus {
  active
  suspended
  deleted
}
```

### Tenant Schema

Cada tenant tiene su propia base de datos con este esquema:

```prisma
// prisma/tenant/schema.prisma

model MonitoredEntity {
  id          String   @id @default(cuid())
  ruc         String   @unique
  name        String
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  
  cases       Case[]
}

model Case {
  id                String   @id @default(cuid())
  expediente        String   @unique
  caseNumber        String
  plaintiff         String
  defendant         String
  subjectMatter     String
  riskLevel         RiskLevel @default(MEDIUM)
  claimAmount       Decimal?
  district          String
  court             String
  currentJudge      String?
  processType       String
  filingDate        DateTime
  status            CaseStatus @default(EN_TRAMITE)
  stageCode         String
  substageCode      String
  monitoredEntityId String
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  monitoredEntity   MonitoredEntity @relation(fields: [monitoredEntityId], references: [id])
  movements         Movement[]
  progress          CaseProgress[]
  milestones        CaseMilestone[]
  snapshots         CaseSnapshot[]
}

model Movement {
  id              String   @id @default(cuid())
  caseId          String
  date            DateTime
  description     String
  resolution      String?
  actor           String?
  classification  MovementClassification
  isNotification  Boolean  @default(false)
  documentUrl     String?
  summary         String?
  rawHtml         String?
  createdAt       DateTime @default(now())
  
  case            Case     @relation(fields: [caseId], references: [id])
  milestone       CaseMilestone?
}

model CaseProgress {
  id            String   @id @default(cuid())
  caseId        String
  stageCode     String
  substageCode  String
  startDate     DateTime
  endDate       DateTime?
  durationDays  Int?
  isCurrent     Boolean  @default(false)
  
  case          Case     @relation(fields: [caseId], references: [id])
}

model CaseMilestone {
  id            String   @id @default(cuid())
  caseId        String
  milestoneCode String
  achievedAt    DateTime
  movementId    String?  @unique
  metadata      Json     @default("{}")
  
  case          Case     @relation(fields: [caseId], references: [id])
  movement      Movement? @relation(fields: [movementId], references: [id])
}

model CaseSnapshot {
  id          String   @id @default(cuid())
  caseId      String
  takenAt     DateTime @default(now())
  status      CaseStatus
  stageCode   String
  substageCode String
  riskLevel   RiskLevel
  metadata    Json     @default("{}")
  
  case        Case     @relation(fields: [caseId], references: [id])
}

enum RiskLevel {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum CaseStatus {
  EN_TRAMITE
  EN_EJECUCION
  ARCHIVADO
  CONCLUIDO
}

enum MovementClassification {
  RESOLUCION
  ESCRITO
  NOTIFICACION
  AUDIENCIA
  OTRO
}
```

## Taxonomía

Clamo incluye tablas de taxonomía para normalizar etapas y hitos procesales:

```prisma
model Stage {
  id          String   @id
  name        String
  order       Int
  description String?
  
  substages   Substage[]
}

model Substage {
  id          String   @id
  stageId     String
  name        String
  order       Int
  description String?
  
  stage       Stage    @relation(fields: [stageId], references: [id])
}

model MilestoneType {
  id          String   @id
  name        String
  stageId     String?
  description String?
  isTerminal  Boolean  @default(false)
}
```

### Etapas Procesales

| Código | Nombre | Descripción |
|--------|--------|-------------|
| `CONOCIMIENTO` | Conocimiento | Fase inicial del proceso |
| `PRUEBAS` | Pruebas | Actuación y valoración de pruebas |
| `SENTENCIA` | Sentencia | Emisión de sentencia |
| `IMPUGNACION` | Impugnación | Recursos de apelación |
| `EJECUCION` | Ejecución | Cumplimiento de sentencia |

## Migraciones

### Ejecutar Migraciones

```bash
# Usando el CLI de Clamo
clamo db migrate stg   # Staging
clamo db migrate prd   # Producción

# Usando Prisma directamente
npx prisma migrate deploy --schema=prisma/control/schema.prisma
npx prisma migrate deploy --schema=prisma/tenant/schema.prisma
```

### Crear Nueva Migración

```bash
# Para el esquema de control
npx prisma migrate dev --schema=prisma/control/schema.prisma --name add_new_field

# Para el esquema de tenant
npx prisma migrate dev --schema=prisma/tenant/schema.prisma --name add_new_field
```

## Cliente Prisma

El paquete exporta clientes Prisma pre-configurados:

```typescript
import { 
  controlPrisma, 
  createTenantPrisma 
} from '@getclamo/database';

// Cliente de control (singleton)
const companies = await controlPrisma.company.findMany();

// Cliente de tenant (dinámico por conexión)
const tenantDb = createTenantPrisma(connectionString);
const cases = await tenantDb.case.findMany();
```

## Utilidades

### Resolución de Tenant

```typescript
import { resolveTenantConnection } from '@getclamo/database';

// Obtiene la connection string del tenant desde Vault
const connectionString = await resolveTenantConnection(companyId);
```

### Pool de Conexiones

```typescript
import { TenantConnectionPool } from '@getclamo/database';

const pool = new TenantConnectionPool({
  maxConnections: 10,
  idleTimeout: 30000,
});

const tenantDb = await pool.getConnection(companyId);
```

## Configuración

### Variables de Entorno

```bash
# Control database
CONTROL_DATABASE_URL=postgresql://user:pass@host:5432/control?sslmode=require

# Supabase (para Vault)
SUPABASE_URL=https://...
SUPABASE_SERVICE_KEY=...

# Neon
NEON_API_KEY=...
```

## Estructura del Paquete

```
clamo-database/
├── prisma/
│   ├── control/
│   │   ├── schema.prisma
│   │   └── migrations/
│   └── tenant/
│       ├── schema.prisma
│       └── migrations/
├── src/
│   ├── clients/
│   │   ├── control.ts
│   │   └── tenant.ts
│   ├── utils/
│   │   ├── resolve-connection.ts
│   │   └── pool.ts
│   └── index.ts
├── package.json
└── tsconfig.json
```

## Desarrollo Local

```bash
# Instalar dependencias
pnpm install

# Generar clientes Prisma
pnpm db:generate

# Abrir Prisma Studio (control)
pnpm studio:control

# Abrir Prisma Studio (tenant)
pnpm studio:tenant

# Build
pnpm build
```

## Consideraciones de Seguridad

<Warning>
Las credenciales de conexión a bases de datos de tenants **nunca** se almacenan en texto plano. Se guardan en Supabase Vault y se resuelven en tiempo de ejecución.
</Warning>

- Las connection strings se obtienen de Supabase Vault usando `pooledConnSecretId` o `directConnSecretId`
- Cada tenant tiene credenciales únicas
- Las conexiones usan SSL obligatorio
- El pool de conexiones limita el número máximo de conexiones por tenant

