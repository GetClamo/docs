---
title: Best Practices
description: Recommendations for a robust integration with Clamo
---

# Best Practices

This guide compiles best practices for integrating your application with Clamo efficiently and robustly.

## Authentication

### Secure Token Storage

<Warning>
**Never store tokens in localStorage or sessionStorage**. Use HttpOnly cookies for the browser.
</Warning>

```typescript
// Correct: HttpOnly Cookie (Next.js)
import { cookies } from 'next/headers';

export async function setSession(accessToken: string, refreshToken: string) {
  const cookieStore = cookies();
  
  cookieStore.set('access_token', accessToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 60, // 1 hour
  });
  
  cookieStore.set('refresh_token', refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 60 * 24 * 7, // 7 days
  });
}
```

### Proactive Refresh

Renew the token before it expires:

```typescript
class TokenManager {
  private accessToken: string;
  private expiresAt: number;
  
  async getToken(): Promise<string> {
    // Renew if less than 5 minutes remaining
    if (this.expiresAt - Date.now() < 5 * 60 * 1000) {
      await this.refresh();
    }
    return this.accessToken;
  }
  
  private async refresh() {
    const { accessToken, expiresIn } = await refreshAccessToken();
    this.accessToken = accessToken;
    this.expiresAt = Date.now() + expiresIn * 1000;
  }
}
```

## API Calls

### Centralize Client

Use a centralized client for all calls:

```typescript
// lib/clamo.ts
class ClamoClient {
  private baseUrl = process.env.CLAMO_API_URL;
  private tokenManager: TokenManager;
  
  constructor() {
    this.tokenManager = new TokenManager();
  }
  
  async request<T>(
    method: string,
    path: string,
    body?: unknown
  ): Promise<T> {
    const token = await this.tokenManager.getToken();
    const session = await this.getSessionToken();
    
    const response = await fetch(`${this.baseUrl}${path}`, {
      method,
      headers: {
        'Authorization': `Bearer ${token}`,
        'x-clamo-session': session,
        'Content-Type': 'application/json',
      },
      body: body ? JSON.stringify(body) : undefined,
    });
    
    if (!response.ok) {
      throw await this.handleError(response);
    }
    
    return response.json();
  }
  
  // Typed methods
  cases = {
    list: (params?: CaseListParams) => 
      this.request<CaseListResponse>('GET', `/v1/cases?${new URLSearchParams(params)}`),
    get: (id: string) => 
      this.request<Case>('GET', `/v1/cases/${id}`),
    update: (id: string, data: UpdateCaseData) => 
      this.request<Case>('PATCH', `/v1/cases/${id}`, data),
  };
}

export const clamo = new ClamoClient();
```

### Avoid N+1 Queries

Instead of making multiple calls, use list endpoints:

```typescript
// Incorrect: N+1 queries
const caseIds = ['case_1', 'case_2', 'case_3'];
const cases = await Promise.all(
  caseIds.map(id => clamo.cases.get(id))
);

// Correct: Single call with filter
const { data: cases } = await clamo.cases.list({
  ids: caseIds.join(','),
});
```

### Efficient Pagination

For large datasets, paginate correctly:

```typescript
async function* getAllCases(): AsyncGenerator<Case> {
  let page = 1;
  let hasMore = true;
  
  while (hasMore) {
    const { data, pagination } = await clamo.cases.list({
      page: page.toString(),
      limit: '100',
    });
    
    for (const caso of data) {
      yield caso;
    }
    
    hasMore = page < pagination.totalPages;
    page++;
  }
}

// Usage
for await (const caso of getAllCases()) {
  processCase(caso);
}
```

## Caching

### Cache Static Data

Cache data that changes infrequently:

```typescript
import { unstable_cache } from 'next/cache';

// Cache taxonomy for 1 hour
const getStages = unstable_cache(
  async () => {
    return clamo.request('GET', '/v1/taxonomy/stages');
  },
  ['taxonomy-stages'],
  { revalidate: 3600 }
);

// Cache company for 5 minutes
const getCompany = unstable_cache(
  async (companyId: string) => {
    return clamo.request('GET', `/v1/companies/${companyId}`);
  },
  ['company'],
  { revalidate: 300 }
);
```

### Cache Invalidation

Invalidate cache when data changes:

```typescript
import { revalidateTag } from 'next/cache';

async function updateCase(id: string, data: UpdateCaseData) {
  const result = await clamo.cases.update(id, data);
  
  // Invalidate related cache
  revalidateTag(`case-${id}`);
  revalidateTag('cases-list');
  
  return result;
}
```

## Optimistic Updates

Update the UI before confirming with the server:

```typescript
function useCaseUpdate(caseId: string) {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (data: UpdateCaseData) => 
      clamo.cases.update(caseId, data),
    
    onMutate: async (newData) => {
      // Cancel in-flight queries
      await queryClient.cancelQueries({ queryKey: ['case', caseId] });
      
      // Snapshot previous state
      const previousCase = queryClient.getQueryData(['case', caseId]);
      
      // Optimistic update
      queryClient.setQueryData(['case', caseId], (old: Case) => ({
        ...old,
        ...newData,
      }));
      
      return { previousCase };
    },
    
    onError: (err, newData, context) => {
      // Rollback on error
      queryClient.setQueryData(['case', caseId], context?.previousCase);
    },
    
    onSettled: () => {
      // Refetch to ensure consistency
      queryClient.invalidateQueries({ queryKey: ['case', caseId] });
    },
  });
}
```

## Webhooks

### Idempotency

Ensure processing the same webhook multiple times doesn't cause issues:

```typescript
const processedEvents = new Set<string>();

async function handleWebhook(event: WebhookEvent) {
  // Check if already processed
  if (processedEvents.has(event.id)) {
    console.log(`Event ${event.id} already processed, skipping`);
    return;
  }
  
  // Or use database for persistence
  const existing = await db.processedWebhooks.findUnique({
    where: { eventId: event.id },
  });
  
  if (existing) {
    return;
  }
  
  // Process event
  await processEvent(event);
  
  // Mark as processed
  await db.processedWebhooks.create({
    data: { eventId: event.id, processedAt: new Date() },
  });
}
```

### Asynchronous Processing

Don't block the webhook waiting for long processing:

```typescript
app.post('/webhooks/clamo', async (req, res) => {
  // Verify signature...
  
  // Queue for async processing
  await queue.add('webhook', {
    event: req.body,
    receivedAt: new Date(),
  });
  
  // Respond immediately
  res.json({ received: true });
});

// Separate worker
queue.process('webhook', async (job) => {
  const { event } = job.data;
  await processWebhook(event);
});
```

## Error Handling

### Specific vs Generic Errors

Provide useful messages to the user:

```typescript
function getErrorMessage(error: ClamoApiError): string {
  // Specific errors with context
  const specificMessages: Record<string, string> = {
    'CASE_NOT_FOUND': 'The case you are looking for does not exist or was deleted.',
    'CASE_ARCHIVED': 'This case is archived and cannot be modified.',
    'PLAN_LIMIT_EXCEEDED': 'You have reached your plan limit. Upgrade to continue.',
    'DUPLICATE_EXPEDIENTE': 'A case with this file number already exists.',
  };
  
  if (specificMessages[error.code]) {
    return specificMessages[error.code];
  }
  
  // Generic messages by category
  if (error.statusCode === 401) {
    return 'Your session has expired. Please log in again.';
  }
  
  if (error.statusCode === 403) {
    return 'You do not have permission to perform this action.';
  }
  
  if (error.statusCode && error.statusCode >= 500) {
    return 'A server error occurred. Please try again in a few minutes.';
  }
  
  return 'An unexpected error occurred.';
}
```

## Security

### Input Validation

Validate data before sending to the API:

```typescript
import { z } from 'zod';

const UpdateCaseSchema = z.object({
  riskLevel: z.enum(['LOW', 'MEDIUM', 'HIGH', 'CRITICAL']).optional(),
  claimAmount: z.number().positive().optional(),
  notes: z.string().max(5000).optional(),
});

async function updateCase(id: string, data: unknown) {
  // Validate before sending
  const validated = UpdateCaseSchema.parse(data);
  
  return clamo.cases.update(id, validated);
}
```

### Log Sanitization

Don't log sensitive data:

```typescript
function sanitizeForLogging(data: unknown): unknown {
  if (typeof data !== 'object' || data === null) {
    return data;
  }
  
  const sensitiveKeys = ['password', 'token', 'secret', 'apiKey', 'connectionString'];
  
  return Object.fromEntries(
    Object.entries(data).map(([key, value]) => [
      key,
      sensitiveKeys.some(k => key.toLowerCase().includes(k))
        ? '[REDACTED]'
        : sanitizeForLogging(value),
    ])
  );
}
```

## Monitoring

### API Metrics

Track call performance:

```typescript
async function trackApiCall<T>(
  name: string,
  fn: () => Promise<T>
): Promise<T> {
  const start = Date.now();
  
  try {
    const result = await fn();
    
    metrics.histogram('api_call_duration_ms', Date.now() - start, {
      endpoint: name,
      status: 'success',
    });
    
    return result;
  } catch (error) {
    metrics.histogram('api_call_duration_ms', Date.now() - start, {
      endpoint: name,
      status: 'error',
      errorCode: error instanceof ClamoApiError ? error.code : 'unknown',
    });
    
    throw error;
  }
}

// Usage
const cases = await trackApiCall('cases.list', () => 
  clamo.cases.list({ status: 'EN_TRAMITE' })
);
```

## Testing

### Mocks for Tests

Mock the Clamo client in tests:

```typescript
// __mocks__/clamo.ts
export const clamo = {
  cases: {
    list: jest.fn(),
    get: jest.fn(),
    update: jest.fn(),
  },
};

// test.spec.ts
import { clamo } from '../lib/clamo';

jest.mock('../lib/clamo');

describe('CaseList', () => {
  it('renders cases', async () => {
    (clamo.cases.list as jest.Mock).mockResolvedValue({
      data: [
        { id: 'case_1', expediente: '00001-2024-...' },
      ],
      pagination: { total: 1 },
    });
    
    render(<CaseList />);
    
    await waitFor(() => {
      expect(screen.getByText('00001-2024-...')).toBeInTheDocument();
    });
  });
});
```

## Integration Checklist

<Steps>
  <Step title="Authentication">
    - Tokens stored securely
    - Automatic refresh implemented
    - Logout clears all tokens
  </Step>
  
  <Step title="API">
    - Centralized client
    - Robust error handling
    - Client-side rate limiting
    - Retry with exponential backoff
  </Step>
  
  <Step title="Webhooks">
    - Signature verification
    - Idempotent processing
    - Asynchronous processing
    - Delivery logging
  </Step>
  
  <Step title="Security">
    - Input validation
    - Log sanitization
    - HTTPS in production
    - Tokens not exposed in frontend
  </Step>
  
  <Step title="Monitoring">
    - Latency metrics
    - Error alerts
    - Structured logs
    - Distributed tracing
  </Step>
</Steps>
