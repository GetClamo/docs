---
title: Best Practices
description: Specific guide for Clamo developers - avoid common mistakes
---

# Best Practices for Developers

This guide documents Clamo-specific practices based on its architecture: **RRS**, **Unified AI**, **Strict Multi-tenant**, and **Trusted Sources**. Follow these rules to avoid the most common mistakes.

## Backend: Zero Trust in Database

<Warning>
**Fundamental Rule:** Never assume you're connected to the correct database.
</Warning>

### Always use `getTenantClient(ctx)`

```typescript
// ❌ INCORRECT: Manually instantiate PrismaClient
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient({
  datasources: {
    db: { url: process.env.DATABASE_URL }, // ← Which tenant?
  },
});

const cases = await prisma.case.findMany(); // ← Whose data?
```

```typescript
// ✅ CORRECT: Use client from context
async function handler(c: Context) {
  const tenantDb = c.get("tenantDb"); // ← Resolved by middleware
  
  const cases = await tenantDb.case.findMany();
  // ✅ Always from the correct tenant
}
```

### Never build connection strings

```typescript
// ❌ INCORRECT: Concatenate strings
const connectionString = `postgresql://${user}:${pass}@${host}/${dbName}`;
const prisma = new PrismaClient({ datasources: { db: { url: connectionString } } });
```

```typescript
// ✅ CORRECT: Use Tenant SDK
import { getTenantClient } from "@getclamo/database";

const tenantDb = await getTenantClient({
  companyId: company.id,
  connectionString, // ← Comes from Tenant SDK, encrypted in Vault
});
```

**Why:** Prevents the catastrophic error of writing Client A's data to Client B's database.

## Data: Respect Source Hierarchy (Trusted Source)

<Warning>
**Fundamental Rule:** Data is not a plain string. It has origin and hierarchy.
</Warning>

### Verify origin before overwriting

```typescript
// ❌ INCORRECT: Overwrite without checking
async function updateCaseFromAI(caseId: string, aiData: AIAnalysis) {
  await tenantDb.case.update({
    where: { id: caseId },
    data: {
      riskLevel: aiData.riskLevel, // ← What if human already corrected it?
    },
  });
}
```

```typescript
// ✅ CORRECT: Verify source hierarchy
async function updateCaseFromAI(caseId: string, aiData: AIAnalysis) {
  const existingCase = await tenantDb.case.findUnique({
    where: { id: caseId },
  });

  const currentRiskLevel = existingCase.riskLevel as SourcedValue;

  // If there's a manual value, DO NOT overwrite with AI
  if (currentRiskLevel.manual !== null) {
    console.log("Skipping AI update - manual value exists");
    return existingCase;
  }

  // Only update AI field, preserve manual
  await tenantDb.case.update({
    where: { id: caseId },
    data: {
      riskLevel: {
        ...currentRiskLevel,
        ai: aiData.riskLevel,
        updatedAt: {
          ...currentRiskLevel.updatedAt,
          ai: new Date().toISOString(),
        },
      },
    },
  });
}
```

### Priority hierarchy

```typescript
// utils/trusted-source.ts
type Source = "cej" | "ai" | "manual";

const SOURCE_PRIORITY: Record<Source, number> = {
  cej: 1,    // Lowest - raw scraper data
  ai: 2,     // Medium - normalized by LLM
  manual: 3, // Highest - corrected by human
};

export function canOverwrite(
  current: SourcedValue,
  newSource: Source
): boolean {
  const currentSource = current.manual ? "manual" 
    : current.ai ? "ai" 
    : "cej";

  // Can only overwrite if equal or higher priority
  return SOURCE_PRIORITY[newSource] >= SOURCE_PRIORITY[currentSource];
}

export function resolveValue<T>(sourced: SourcedValue<T>): T | null {
  // Manual > AI > CEJ
  return sourced.manual ?? sourced.ai ?? sourced.cej ?? null;
}
```

## Code: RRS Pattern (Repository-Route-Service)

<Warning>
**Fundamental Rule:** Each layer has a single responsibility. Don't mix them.
</Warning>

### Route: Only validation and response

```typescript
// ✅ CORRECT
app.patch("/:id", zValidator("json", UpdateSchema), async (c) => {
  const id = c.req.param("id");
  const data = c.req.valid("json");
  const tenantDb = c.get("tenantDb");

  const result = await caseService.updateCase(tenantDb, id, data);

  return c.json(result);
});
```

```typescript
// ❌ INCORRECT: Business logic in Route
app.patch("/:id", async (c) => {
  const id = c.req.param("id");
  const tenantDb = c.get("tenantDb");

  // ❌ Prisma query in controller
  const existing = await tenantDb.case.findUnique({ where: { id } });

  // ❌ Business logic in controller
  if (existing.status === "ARCHIVED") {
    return c.json({ error: "Cannot update" }, 400);
  }

  // ❌ More queries in controller
  const updated = await tenantDb.case.update({ where: { id }, data });

  return c.json(updated);
});
```

### Service: Business logic

```typescript
// ✅ CORRECT: All logic here
class CaseService {
  async updateCase(tenantDb: PrismaClient, id: string, data: UpdateInput) {
    const existing = await this.caseRepo.findById(tenantDb, id);

    if (!existing) {
      throw new NotFoundError("Case not found");
    }

    if (existing.status === "ARCHIVED") {
      throw new BusinessError("Cannot update archived case");
    }

    // Trusted Source logic
    const updateData = this.prepareUpdate(existing, data);

    return this.caseRepo.update(tenantDb, id, updateData);
  }
}
```

### Repository: Only data access

```typescript
// ✅ CORRECT: Only Prisma here
class CaseRepository {
  async findById(db: PrismaClient, id: string) {
    return db.case.findUnique({ where: { id } });
  }

  async update(db: PrismaClient, id: string, data: UpdateData) {
    return db.case.update({ where: { id }, data });
  }
}
```

## AI: Context Before Question

<Warning>
**Fundamental Rule:** Luna is blind without context. Always inject the necessary state.
</Warning>

### Always pass the correct `assistant_name`

```typescript
// ❌ INCORRECT: Not specifying profile
const response = await fetch(`${LANGGRAPH_URL}/runs`, {
  method: "POST",
  body: JSON.stringify({
    input: { messages: [{ role: "user", content: "Give me the case summary" }] },
    // ← Javi? Clamy? Luna?
  }),
});
```

```typescript
// ✅ CORRECT: Specify profile and context
const response = await fetch(`${LANGGRAPH_URL}/runs`, {
  method: "POST",
  body: JSON.stringify({
    assistant_id: "luna",
    input: {
      messages: [{ role: "user", content: "Give me the case summary" }],
    },
    config: {
      configurable: {
        assistant_name: "javi",  // ← Specific profile
        case_id: caseId,         // ← Case context
        company_id: companyId,   // ← Tenant context
      },
    },
  }),
});
```

### Inject IDs, don't expect the LLM to guess

```typescript
// ❌ INCORRECT: Expecting LLM to extract from history
const messages = [
  { role: "user", content: "Let's talk about case 00001-2024-..." },
  { role: "assistant", content: "Sure, that case has..." },
  { role: "user", content: "What's the risk?" }, // ← Which case?
];
```

```typescript
// ✅ CORRECT: Inject in state
const response = await langgraph.invoke({
  messages: [{ role: "user", content: "What's the risk?" }],
  config: {
    configurable: {
      case_id: "case_abc123", // ← Explicit, not ambiguous
    },
  },
});
```

## Multi-Tenancy: Strict Isolation

### Never trust URL for authenticated users

```typescript
// ❌ INCORRECT: Use companyId from URL
app.get("/companies/:companyId/cases", async (c) => {
  const companyId = c.req.param("companyId"); // ← What if they manipulate it?
  const tenantDb = await getTenantClient({ companyId });
  // ...
});
```

```typescript
// ✅ CORRECT: Use orgId from token (via middleware)
app.get("/v1/cases", async (c) => {
  const tenantDb = c.get("tenantDb"); // ← Resolved from x-workos-org-id
  // Middleware already validated and resolved the correct tenant
});
```

### Internal endpoints: Yes, use URL

```typescript
// ✅ CORRECT for /internal/... endpoints
app.get("/internal/v1/companies/:companyId/cases", async (c) => {
  const companyId = c.req.param("companyId");
  // OK because only internal services can call here
  const tenantDb = await getTenantClient({ companyId, connectionString });
});
```

## Service-to-Service Communication

### Always use SDKs, never direct queries

```typescript
// ❌ INCORRECT: Direct query to another DB
// From clamo-cases trying to read clamo-tenant data
const company = await controlDb.company.findUnique({
  where: { id: companyId },
});
```

```typescript
// ✅ CORRECT: Use SDK
import Tenant from "@getclamo/tenant";

const tenant = new Tenant({ baseURL: env.TENANT_SERVICE_URL });
const company = await tenant.internal.companies.get(companyId);
```

### Use internal endpoints for service-to-service

```typescript
// ❌ INCORRECT: Call public endpoint from backend
const response = await fetch(`${CASES_URL}/v1/cases/${caseId}`, {
  headers: { Authorization: `Bearer ${???}` }, // ← What token?
});
```

```typescript
// ✅ CORRECT: Use internal endpoint
const response = await fetch(
  `${CASES_URL}/internal/v1/companies/${companyId}/cases/${caseId}`
);
// No auth - internal network is trusted
```

## Pull Request Checklist

Before submitting a PR, verify:

<Steps>
  <Step title="RRS Pattern">
    - [ ] Routes only validate with Zod and respond JSON
    - [ ] Services contain all business logic
    - [ ] Repositories are the only ones importing `@getclamo/database`
  </Step>
  
  <Step title="Multi-Tenancy">
    - [ ] No manual `new PrismaClient()`
    - [ ] Using `c.get("tenantDb")` from context
    - [ ] Not trusting `companyId` from URL for authenticated users
  </Step>
  
  <Step title="Trusted Source">
    - [ ] Verifying origin before overwriting SourcedValue fields
    - [ ] Not overwriting `manual` with `ai` or `cej` in batch processes
    - [ ] Using `resolveValue()` to get final value
  </Step>
  
  <Step title="AI/Luna">
    - [ ] Passing `assistant_name` in all invocations
    - [ ] Injecting `case_id` and `company_id` in config
    - [ ] Not expecting LLM to guess context from history
  </Step>
  
  <Step title="Communication">
    - [ ] Using SDKs for service-to-service calls
    - [ ] Using `/internal/v1/...` for service-to-service
    - [ ] Not making direct queries to other domain DBs
  </Step>
</Steps>

## Next Steps

<CardGroup cols={2}>
  <Card
    title="RRS Pattern"
    icon="layer-group"
    href="/en/architecture/rrs-pattern"
  >
    Detailed documentation of Repository-Route-Service pattern.
  </Card>
  <Card
    title="Data Model"
    icon="database"
    href="/en/architecture/data-model"
  >
    SourcedValue pattern for multi-origin data.
  </Card>
  <Card
    title="Errors"
    icon="triangle-exclamation"
    href="/en/guides/errors"
  >
    Troubleshooting Clamo-specific errors.
  </Card>
  <Card
    title="Security"
    icon="shield"
    href="/en/architecture/security"
  >
    Chain of trust and tenant isolation.
  </Card>
</CardGroup>
