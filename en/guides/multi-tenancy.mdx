---
title: Multi-Tenancy
description: Database-per-tenant architecture with Neon PostgreSQL
---

# Multi-Tenancy in Clamo

Clamo implements a **database-per-tenant** model that provides complete data isolation between companies.

## Architecture

```mermaid
flowchart TB
    subgraph Control [Control Plane - Supabase]
        ControlDB[(Control DB)]
        Vault[Vault Secrets]
    end
    
    subgraph Tenants [Data Plane - Neon]
        T1[(Company A<br/>Branch)]
        T2[(Company B<br/>Branch)]
        T3[(Company C<br/>Branch)]
    end
    
    subgraph App [Application]
        API[Clamo API]
        Resolver[Tenant Resolver]
    end
    
    API --> Resolver
    Resolver --> ControlDB
    ControlDB --> Vault
    Vault --> T1
    Vault --> T2
    Vault --> T3
```

## Data Model

### Control Database

The control database stores global information:

| Table | Description |
|-------|-------------|
| `Company` | Registered companies |
| `User` | Users from all companies |
| `CompanyDatabase` | Database credentials and metadata |

### Tenant Databases

Each company has its own database with:

| Table | Description |
|-------|-------------|
| `MonitoredEntity` | Monitored entities (RUCs) |
| `Case` | Judicial cases |
| `Movement` | Procedural movements |
| `CaseProgress` | Stage history |
| `CaseMilestone` | Achieved milestones |

## Provisioning Flow

When a new company is created:

```mermaid
sequenceDiagram
    participant Admin
    participant API as clamo-tenant
    participant Neon
    participant Vault as Supabase Vault
    participant DB as Control DB

    Admin->>API: POST /admin/companies
    API->>Neon: Create Branch
    Neon-->>API: branch_id, connection_uri
    API->>API: Encrypt credentials
    API->>Vault: Store pooled_conn_secret
    API->>Vault: Store direct_conn_secret
    Vault-->>API: secret_ids
    API->>DB: Insert CompanyDatabase
    API-->>Admin: Company ready
```

### Provisioning Code

```typescript
// Simplified from clamo-tenant/provisioning.service.ts
async function provisionTenantDatabase(company: Company) {
  // 1. Create branch in Neon
  const branch = await neonClient.createBranch({
    projectId: NEON_PROJECT_ID,
    name: `tenant-${company.id}`,
  });
  
  // 2. Get connection strings
  const endpoint = await neonClient.createEndpoint({
    branchId: branch.id,
    type: 'read_write',
  });
  
  const pooledUri = `postgres://${endpoint.host}:5432/${DB_NAME}?sslmode=require`;
  const directUri = `postgres://${endpoint.host}:5432/${DB_NAME}?sslmode=require`;
  
  // 3. Store in Vault
  const pooledSecretId = await vault.createSecret({
    name: `tenant-${company.id}-pooled`,
    value: pooledUri,
  });
  
  const directSecretId = await vault.createSecret({
    name: `tenant-${company.id}-direct`,
    value: directUri,
  });
  
  // 4. Save metadata
  await prisma.companyDatabase.create({
    data: {
      companyId: company.id,
      neonProjectId: NEON_PROJECT_ID,
      neonBranchId: branch.id,
      neonEndpointId: endpoint.id,
      databaseName: DB_NAME,
      databaseHost: endpoint.host,
      databaseUser: 'neondb_owner',
      pooledConnSecretId: pooledSecretId,
      directConnSecretId: directSecretId,
    },
  });
  
  // 5. Run migrations
  await runMigrations(directUri);
}
```

## Tenant Resolution

Each request dynamically resolves the tenant connection:

```typescript
// Resolution middleware
async function resolveTenant(c: Context, next: Next) {
  // 1. Extract companyId from session token
  const session = decodeSession(c.req.header('x-clamo-session'));
  const { companyId } = session;
  
  // 2. Find credentials
  const companyDb = await controlPrisma.companyDatabase.findUnique({
    where: { companyId },
  });
  
  if (!companyDb || companyDb.status !== 'active') {
    throw new Error('Tenant database not available');
  }
  
  // 3. Get connection string from Vault
  const connectionUri = await vault.getSecret(companyDb.pooledConnSecretId);
  
  // 4. Create Prisma client
  const tenantPrisma = new PrismaClient({
    datasources: {
      db: { url: connectionUri },
    },
  });
  
  // 5. Attach to context
  c.set('tenantDb', tenantPrisma);
  
  await next();
  
  // 6. Cleanup
  await tenantPrisma.$disconnect();
}
```

## Connection Pool

To optimize connection usage, Clamo implements a pool:

```typescript
class TenantConnectionPool {
  private connections = new Map<string, PrismaClient>();
  private lastAccess = new Map<string, number>();
  
  async getConnection(companyId: string): Promise<PrismaClient> {
    // Check cache
    if (this.connections.has(companyId)) {
      this.lastAccess.set(companyId, Date.now());
      return this.connections.get(companyId)!;
    }
    
    // Create new connection
    const connectionUri = await this.resolveConnectionUri(companyId);
    const client = new PrismaClient({
      datasources: { db: { url: connectionUri } },
    });
    
    this.connections.set(companyId, client);
    this.lastAccess.set(companyId, Date.now());
    
    return client;
  }
  
  // Cleanup idle connections
  async cleanup() {
    const now = Date.now();
    const IDLE_TIMEOUT = 5 * 60 * 1000; // 5 minutes
    
    for (const [companyId, lastAccess] of this.lastAccess) {
      if (now - lastAccess > IDLE_TIMEOUT) {
        const client = this.connections.get(companyId);
        await client?.$disconnect();
        this.connections.delete(companyId);
        this.lastAccess.delete(companyId);
      }
    }
  }
}
```

## Security Considerations

### Data Isolation

- Each tenant has its own physical database (Neon branch)
- Credentials are encrypted in Supabase Vault
- No possibility of cross-tenant data leakage

### Credentials

```typescript
// Credentials are NEVER exposed in logs or responses
const connectionUri = await vault.getSecret(secretId);

// Secure usage
const client = new PrismaClient({
  datasources: { db: { url: connectionUri } },
  log: ['error'], // Don't log queries that could contain data
});
```

### Tenant Validation

```typescript
// Always validate that the user belongs to the tenant
async function validateTenantAccess(userId: string, companyId: string) {
  const user = await controlPrisma.user.findFirst({
    where: {
      id: userId,
      companyId: companyId,
    },
  });
  
  if (!user) {
    throw new ForbiddenError('You do not have access to this company');
  }
  
  return user;
}
```

## Neon Branching

Clamo leverages Neon branching for:

### Development Environments

```typescript
// Create development branch from production
const devBranch = await neonClient.createBranch({
  projectId: NEON_PROJECT_ID,
  parentId: productionBranchId,
  name: `dev-${Date.now()}`,
});
```

### Point-in-Time Recovery

```typescript
// Restore to a specific point
const recoveryBranch = await neonClient.createBranch({
  projectId: NEON_PROJECT_ID,
  parentId: tenantBranchId,
  name: `recovery-${tenantId}`,
  pointInTime: '2025-01-01T00:00:00Z',
});
```

## Schema Migration

Migrations are run on all tenant databases:

```typescript
async function migrateAllTenants() {
  const companies = await controlPrisma.companyDatabase.findMany({
    where: { status: 'active' },
  });
  
  for (const company of companies) {
    const connectionUri = await vault.getSecret(company.directConnSecretId);
    
    try {
      await runPrismaMigrations(connectionUri);
      console.log(`Migrated tenant: ${company.companyId}`);
    } catch (error) {
      console.error(`Failed to migrate tenant: ${company.companyId}`, error);
    }
  }
}
```

## Monitoring

### Metrics per Tenant

```typescript
// Track usage per tenant
async function trackTenantUsage(companyId: string, operation: string) {
  await analytics.track({
    event: 'tenant_operation',
    properties: {
      companyId,
      operation,
      timestamp: new Date().toISOString(),
    },
  });
}
```

### Health Checks

```typescript
async function checkTenantHealth(companyId: string) {
  const pool = getTenantConnectionPool();
  const client = await pool.getConnection(companyId);
  
  try {
    await client.$queryRaw`SELECT 1`;
    return { status: 'healthy' };
  } catch (error) {
    return { status: 'unhealthy', error: error.message };
  }
}
```

## Plan Limits

| Plan | Case Limit | User Limit | Storage |
|------|------------|------------|---------|
| Free | 100 | 2 | 1 GB |
| Pro | 10,000 | 20 | 10 GB |
| Enterprise | Unlimited | Unlimited | Unlimited |

```typescript
async function checkPlanLimits(companyId: string) {
  const company = await controlPrisma.company.findUnique({
    where: { id: companyId },
    include: { database: true },
  });
  
  const limits = PLAN_LIMITS[company.plan];
  
  const tenantDb = await getTenantConnection(companyId);
  const caseCount = await tenantDb.case.count();
  
  if (caseCount >= limits.maxCases) {
    throw new PlanLimitError('You have reached the case limit for your plan');
  }
}
```

## Next Steps

<CardGroup cols={2}>
  <Card
    title="Webhooks"
    icon="webhook"
    href="/en/guides/webhooks"
  >
    Receive event notifications.
  </Card>
  <Card
    title="Architecture"
    icon="sitemap"
    href="/en/getting-started/architecture"
  >
    System overview.
  </Card>
</CardGroup>

