---
title: Errores
description: Códigos de error, formatos de respuesta y soluciones comunes
---

# Manejo de Errores

Las APIs de Clamo utilizan códigos HTTP estándar y un formato de error consistente para facilitar el diagnóstico de problemas.

## Formato de Error

Todos los errores siguen esta estructura:

```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "Descripción legible del error",
    "details": {
      // Información adicional específica del error
    }
  }
}
```

## Códigos HTTP

### Errores del Cliente (4xx)

| Código | Nombre | Descripción |
|--------|--------|-------------|
| 400 | Bad Request | La request es inválida o malformada |
| 401 | Unauthorized | Autenticación requerida o inválida |
| 403 | Forbidden | Sin permisos para el recurso |
| 404 | Not Found | El recurso no existe |
| 409 | Conflict | Conflicto con el estado actual |
| 422 | Unprocessable Entity | Error de validación de negocio |
| 429 | Too Many Requests | Rate limit excedido |

### Errores del Servidor (5xx)

| Código | Nombre | Descripción |
|--------|--------|-------------|
| 500 | Internal Server Error | Error inesperado del servidor |
| 502 | Bad Gateway | Error de servicio upstream |
| 503 | Service Unavailable | Servicio temporalmente no disponible |
| 504 | Gateway Timeout | Timeout de servicio upstream |

## Códigos de Error

### Autenticación

| Código | HTTP | Descripción | Solución |
|--------|------|-------------|----------|
| `UNAUTHORIZED` | 401 | Token no proporcionado | Incluir header Authorization |
| `INVALID_TOKEN` | 401 | Token malformado o inválido | Verificar formato del token |
| `TOKEN_EXPIRED` | 401 | Token expirado | Renovar con refresh token |
| `INVALID_SESSION` | 401 | Session token inválido | Regenerar session token |
| `FORBIDDEN` | 403 | Sin permisos | Verificar rol del usuario |
| `ORGANIZATION_MISMATCH` | 403 | Organización incorrecta | Usar token de la organización correcta |

### Validación

| Código | HTTP | Descripción | Solución |
|--------|------|-------------|----------|
| `VALIDATION_ERROR` | 400 | Error de validación de campos | Revisar campos en `details` |
| `MISSING_FIELD` | 400 | Campo requerido faltante | Incluir el campo indicado |
| `INVALID_FORMAT` | 400 | Formato de campo incorrecto | Corregir formato según spec |
| `INVALID_ENUM` | 400 | Valor no permitido | Usar valor de la lista permitida |

### Recursos

| Código | HTTP | Descripción | Solución |
|--------|------|-------------|----------|
| `NOT_FOUND` | 404 | Recurso no existe | Verificar ID del recurso |
| `ALREADY_EXISTS` | 409 | Recurso duplicado | Usar recurso existente o cambiar identificador |
| `CONFLICT` | 409 | Conflicto de estado | Refrescar y reintentar |

### Negocio

| Código | HTTP | Descripción | Solución |
|--------|------|-------------|----------|
| `COMPANY_NOT_READY` | 422 | Base de datos no aprovisionada | Esperar a que `databaseStatus` sea `ready` |
| `ONBOARDING_INCOMPLETE` | 422 | Onboarding pendiente | Completar flujo de onboarding |
| `PLAN_LIMIT_EXCEEDED` | 422 | Límite del plan alcanzado | Actualizar plan o contactar soporte |
| `CASE_ARCHIVED` | 422 | Caso archivado | No se pueden modificar casos archivados |

### Rate Limiting

| Código | HTTP | Descripción | Solución |
|--------|------|-------------|----------|
| `RATE_LIMIT_EXCEEDED` | 429 | Demasiadas requests | Esperar y reintentar con backoff |

### Servidor

| Código | HTTP | Descripción | Solución |
|--------|------|-------------|----------|
| `INTERNAL_ERROR` | 500 | Error interno | Reintentar o contactar soporte |
| `DATABASE_ERROR` | 500 | Error de base de datos | Reintentar |
| `EXTERNAL_SERVICE_ERROR` | 502 | Error de servicio externo | Reintentar más tarde |
| `SERVICE_UNAVAILABLE` | 503 | Servicio no disponible | Reintentar más tarde |

## Ejemplos de Errores

### Error de Validación

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Error de validación en los datos enviados",
    "details": {
      "errors": [
        {
          "field": "expediente",
          "message": "El formato del expediente es inválido",
          "constraint": "pattern",
          "expected": "XXXXX-XXXX-X-XXXX-XX-XX-XX"
        },
        {
          "field": "riskLevel",
          "message": "Valor no permitido",
          "constraint": "enum",
          "allowed": ["LOW", "MEDIUM", "HIGH", "CRITICAL"]
        }
      ]
    }
  }
}
```

### Error de Autenticación

```json
{
  "error": {
    "code": "TOKEN_EXPIRED",
    "message": "El token de acceso ha expirado",
    "details": {
      "expiredAt": "2025-01-02T10:00:00Z",
      "hint": "Usa el refresh token para obtener un nuevo access token"
    }
  }
}
```

### Error de Recurso No Encontrado

```json
{
  "error": {
    "code": "NOT_FOUND",
    "message": "El caso solicitado no existe",
    "details": {
      "resource": "Case",
      "id": "case_abc123"
    }
  }
}
```

### Error de Rate Limit

```json
{
  "error": {
    "code": "RATE_LIMIT_EXCEEDED",
    "message": "Has excedido el límite de requests",
    "details": {
      "limit": 100,
      "window": "1 minuto",
      "retryAfter": 45
    }
  }
}
```

## Manejo de Errores en Código

### JavaScript/TypeScript

```typescript
async function fetchCases() {
  const response = await fetch('https://api.clamo.dev/v1/cases', {
    headers: {
      'Authorization': `Bearer ${token}`,
    },
  });

  if (!response.ok) {
    const { error } = await response.json();
    
    switch (error.code) {
      case 'TOKEN_EXPIRED':
        // Renovar token y reintentar
        await refreshToken();
        return fetchCases();
        
      case 'RATE_LIMIT_EXCEEDED':
        // Esperar y reintentar
        const retryAfter = error.details.retryAfter * 1000;
        await new Promise(resolve => setTimeout(resolve, retryAfter));
        return fetchCases();
        
      case 'VALIDATION_ERROR':
        // Mostrar errores al usuario
        error.details.errors.forEach(err => {
          console.error(`${err.field}: ${err.message}`);
        });
        throw new ValidationError(error.details.errors);
        
      default:
        throw new ApiError(error.code, error.message);
    }
  }

  return response.json();
}
```

### Python

```python
import httpx
import time

def fetch_cases(token):
    response = httpx.get(
        "https://api.clamo.dev/v1/cases",
        headers={
            "Authorization": f"Bearer {token}",
        }
    )
    
    if response.status_code >= 400:
        error = response.json()["error"]
        
        if error["code"] == "TOKEN_EXPIRED":
            new_token = refresh_token()
            return fetch_cases(new_token)
            
        elif error["code"] == "RATE_LIMIT_EXCEEDED":
            retry_after = error["details"]["retryAfter"]
            time.sleep(retry_after)
            return fetch_cases(token)
            
        elif error["code"] == "VALIDATION_ERROR":
            for err in error["details"]["errors"]:
                print(f"{err['field']}: {err['message']}")
            raise ValidationError(error["details"]["errors"])
            
        else:
            raise ApiError(error["code"], error["message"])
    
    return response.json()
```

## Retry con Exponential Backoff

Para errores transitorios (5xx, rate limits), implementa retry con backoff:

```typescript
async function fetchWithRetry(
  url: string,
  options: RequestInit,
  maxRetries = 3
) {
  let lastError: Error;
  
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);
      
      if (response.status === 429) {
        const { error } = await response.json();
        const retryAfter = error.details?.retryAfter || Math.pow(2, attempt);
        await new Promise(r => setTimeout(r, retryAfter * 1000));
        continue;
      }
      
      if (response.status >= 500) {
        const backoff = Math.pow(2, attempt) * 1000;
        await new Promise(r => setTimeout(r, backoff));
        continue;
      }
      
      return response;
    } catch (error) {
      lastError = error as Error;
      const backoff = Math.pow(2, attempt) * 1000;
      await new Promise(r => setTimeout(r, backoff));
    }
  }
  
  throw lastError!;
}
```

## Headers de Diagnóstico

Las respuestas incluyen headers útiles para debugging:

| Header | Descripción |
|--------|-------------|
| `X-Request-Id` | ID único de la request |
| `X-RateLimit-Limit` | Límite de requests |
| `X-RateLimit-Remaining` | Requests restantes |
| `X-RateLimit-Reset` | Timestamp de reset |

Incluye el `X-Request-Id` al contactar soporte para facilitar el diagnóstico.

## Próximos Pasos

<CardGroup cols={2}>
  <Card
    title="Inicio Rápido"
    icon="rocket"
    href="/es/inicio/inicio-rapido"
  >
    Comienza a integrar con las APIs.
  </Card>
  <Card
    title="Guía de Errores"
    icon="book"
    href="/es/guias/errores"
  >
    Guía completa de manejo de errores.
  </Card>
</CardGroup>
