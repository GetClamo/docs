---
title: Errores y Troubleshooting
description: Guía de errores específicos de la arquitectura de Clamo y cómo resolverlos
---

# Errores y Troubleshooting

Esta guía documenta los errores específicos de la arquitectura de Clamo: **Multi-tenancy**, **Unified AI**, **Trusted Sources** y **Comunicación Interna**. Aprende a diagnosticar y resolver los problemas más comunes.

## Errores de Multi-Tenancy

### COMPANY_NOT_READY (422)

**Síntomas:**
- API retorna 422 al intentar acceder a datos
- El usuario acaba de crear su cuenta

**Causa:** La empresa se creó en Supabase pero Neon aún está provisionando el branch de base de datos (Cold Start de ~5-10 segundos).

```json
{
  "error": {
    "code": "COMPANY_NOT_READY",
    "message": "La base de datos de la empresa está siendo configurada",
    "details": {
      "databaseStatus": "provisioning"
    }
  }
}
```

**Solución:** Implementar polling sobre el campo `databaseStatus`:

```typescript
async function waitForCompanyReady(companyId: string): Promise<Company> {
  const maxAttempts = 12; // 60 segundos máximo
  const interval = 5000; // 5 segundos

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const company = await tenant.companies.get(companyId);

    switch (company.databaseStatus) {
      case "ready":
        return company;
      case "failed":
        throw new Error("Database provisioning failed");
      case "provisioning":
        await sleep(interval);
        continue;
    }
  }

  throw new Error("Timeout waiting for database");
}
```

**En el Frontend:**

```tsx
function OnboardingStatus({ companyId }: { companyId: string }) {
  const { data: company, isLoading } = useQuery({
    queryKey: ["company", companyId],
    queryFn: () => tenant.companies.get(companyId),
    refetchInterval: (data) => 
      data?.databaseStatus === "provisioning" ? 5000 : false,
  });

  if (company?.databaseStatus === "provisioning") {
    return <Spinner message="Configurando tu espacio de trabajo..." />;
  }

  return <Dashboard />;
}
```

### Connection Timeout a Tenant DB

**Síntomas:**
- Timeouts esporádicos en queries
- Errores `ECONNREFUSED` o `Connection terminated`

**Causa:** El branch de Neon entró en modo "sleep" por inactividad (Neon suspende branches inactivos).

**Solución:** Implementar retry con backoff:

```typescript
async function queryWithRetry<T>(
  fn: () => Promise<T>,
  maxRetries = 3
): Promise<T> {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (isConnectionError(error) && attempt < maxRetries - 1) {
        // Neon cold start: esperar y reintentar
        await sleep(Math.pow(2, attempt) * 1000);
        continue;
      }
      throw error;
    }
  }
  throw new Error("Max retries exceeded");
}

function isConnectionError(error: unknown): boolean {
  const message = error instanceof Error ? error.message : "";
  return (
    message.includes("ECONNREFUSED") ||
    message.includes("Connection terminated") ||
    message.includes("timeout")
  );
}
```

## Errores de AI (Tool Guard)

### TOOL_NOT_ALLOWED

**Síntomas:**
- El LLM dice que "no puede" hacer algo que debería poder
- La herramienta existe pero no se ejecuta

**Causa:** Estás hablando con el perfil incorrecto. Cada perfil (Javi, Clamy, Luna) tiene herramientas específicas. El middleware de Tool Guard bloquea herramientas no permitidas.

```
Usuario: "Muéstrame una gráfica de casos por mes"
Javi: "Lo siento, no tengo acceso a herramientas de visualización"
       ← Javi es para casos, Clamy es para analytics
```

**Diagnóstico:**

```typescript
// Verificar qué perfil está activo
const config = runConfig.configurable;
console.log("Active profile:", config.assistant_name);
console.log("Requested tool:", toolCall.name);

// Ver herramientas permitidas por perfil
const PROFILE_TOOLS = {
  javi: ["get_case", "search_cases", "get_movements"],
  clamy: ["show_chart", "get_analytics", "compare_periods"],
  luna: ["*"], // Luna tiene acceso a todo
};
```

**Solución:** Cambiar de perfil según la intención:

```typescript
function detectIntentAndProfile(message: string): string {
  if (message.match(/gráfica|chart|analytics|estadísticas/i)) {
    return "clamy";
  }
  if (message.match(/caso|expediente|movimiento|demanda/i)) {
    return "javi";
  }
  return "luna"; // Default para preguntas generales
}

// En el frontend
const profile = detectIntentAndProfile(userMessage);
await invokeGraph({
  config: {
    configurable: {
      assistant_name: profile,
    },
  },
});
```

### LLM Alucinando Herramientas

**Síntomas:**
- El LLM intenta llamar herramientas que no existen
- Errores `Tool 'xyz' not found`

**Causa:** El LLM no tiene la lista actualizada de herramientas disponibles.

**Solución:** Asegurarse de que el system prompt incluya las herramientas:

```typescript
// luna/src/prompts/javi.py
JAVI_SYSTEM_PROMPT = """
Eres Javi, el asistente de casos legales de Clamo.

## Herramientas Disponibles
SOLO puedes usar estas herramientas:
- get_case(case_id): Obtener detalles de un caso
- search_cases(query): Buscar casos
- get_movements(case_id): Obtener movimientos de un caso

NO intentes usar herramientas que no están en esta lista.
"""
```

## Errores de Autenticación Interna

### MISSING_AUTH_HEADERS

**Síntomas:**
- Error 401 al llamar desde un microservicio a otro
- Headers `x-workos-*` no presentes

**Causa:** Un desarrollador intentó llamar a un endpoint público (`/v1/...`) desde otro microservicio, saltándose Kong.

```typescript
// ❌ INCORRECTO: Llamar endpoint público desde backend
const response = await fetch(`${CASES_URL}/v1/cases/${caseId}`);
// Error: No hay headers x-workos-* porque no pasó por Kong
```

**Solución:** Usar endpoints internos para servicio-a-servicio:

```typescript
// ✅ CORRECTO: Usar endpoint interno
const response = await fetch(
  `${CASES_URL}/internal/v1/companies/${companyId}/cases/${caseId}`
);
// OK: Endpoints internos no requieren auth (red confiable)
```

**O usar el SDK:**

```typescript
// ✅ CORRECTO: Usar SDK
import Cases from "@getclamo/cases";

const cases = new Cases({ baseURL: env.CASES_SERVICE_URL });
const caseData = await cases.internal.companies(companyId).cases.get(caseId);
```

### ORGANIZATION_MISMATCH

**Síntomas:**
- Error 403 al acceder a recursos
- El usuario está autenticado pero no puede ver datos

**Causa:** El token JWT tiene un `org_id` diferente al de la empresa que intenta acceder.

```json
{
  "error": {
    "code": "ORGANIZATION_MISMATCH",
    "message": "No tienes acceso a esta organización",
    "details": {
      "tokenOrgId": "org_abc",
      "requestedOrgId": "org_xyz"
    }
  }
}
```

**Diagnóstico:**

```typescript
// Verificar el org_id del token
const session = c.get("session");
console.log("Token org_id:", session.orgId);

// Verificar la empresa solicitada
const company = await controlDb.company.findUnique({
  where: { id: requestedCompanyId },
});
console.log("Company workosOrgId:", company.workosOrgId);
```

**Solución:** El usuario debe cambiar de organización en WorkOS:

```typescript
// Frontend: Org switcher
import { getSignInUrl } from "@workos-inc/authkit-nextjs";

async function switchOrganization(orgId: string) {
  const signInUrl = await getSignInUrl({
    organizationId: orgId,
  });
  window.location.href = signInUrl;
}
```

## Errores de Ingesta Asíncrona

### Estado Inconsistente de Caso

**Síntomas:**
- El caso existe pero no tiene movimientos
- Datos parciales o incompletos

**Causa:** El `CaseIngestRun` está en un estado intermedio, no en `COMPLETED`.

```typescript
// Estados del CaseIngestRun
enum IngestRunStatus {
  RUNNING = "RUNNING",                    // Scraping en progreso
  MOVEMENTS_COMPLETE = "MOVEMENTS_COMPLETE", // Movimientos extraídos
  ANALYSIS_COMPLETE = "ANALYSIS_COMPLETE",   // IA procesó
  COMPLETED = "COMPLETED",                // Todo listo
  FAILED = "FAILED",                      // Error
}
```

**Diagnóstico:**

```sql
-- Verificar estado del ingest run
SELECT 
  ir.id,
  ir.status,
  ir."startedAt",
  ir."completedAt",
  ir.error,
  c.expediente
FROM "CaseIngestRun" ir
JOIN "Case" c ON ir."caseId" = c.id
WHERE c.id = 'case_xyz'
ORDER BY ir."startedAt" DESC
LIMIT 1;
```

**Solución:** No tratar la data como final hasta `COMPLETED`:

```typescript
// En el frontend
function CaseDetail({ caseId }: { caseId: string }) {
  const { data: caseData } = useQuery(["case", caseId], () => 
    cases.get(caseId)
  );
  
  const { data: ingestRun } = useQuery(["ingest-run", caseId], () =>
    cases.ingestRuns.getLatest(caseId)
  );

  if (ingestRun?.status !== "COMPLETED") {
    return (
      <Alert variant="info">
        <Spinner size="sm" />
        <span>
          {ingestRun?.status === "RUNNING" && "Extrayendo datos del CEJ..."}
          {ingestRun?.status === "MOVEMENTS_COMPLETE" && "Analizando con IA..."}
          {ingestRun?.status === "ANALYSIS_COMPLETE" && "Finalizando..."}
        </span>
      </Alert>
    );
  }

  return <CaseDetails case={caseData} />;
}
```

### INGEST_RUN_FAILED

**Síntomas:**
- El caso se quedó sin actualizar
- Error en el pipeline de ingesta

**Causa:** Fallo en alguna etapa del pipeline (scraping, normalización, inserción).

**Diagnóstico:**

```typescript
// Obtener detalles del error
const ingestRun = await cases.internal
  .companies(companyId)
  .ingestRuns.get(runId);

console.log("Status:", ingestRun.status);
console.log("Error:", ingestRun.error);
console.log("Failed at:", ingestRun.failedAt);

// Errores comunes:
// - "CEJ_TIMEOUT": El CEJ no respondió
// - "PARSE_ERROR": HTML del CEJ cambió
// - "LLM_ERROR": Anthropic falló
// - "DB_ERROR": Error al insertar
```

**Solución:** Reintentar la ingesta:

```typescript
// Reintentar ingesta fallida
await cases.internal.companies(companyId).ingestRuns.create({
  caseId: caseId,
  expediente: expediente,
  source: "MANUAL_RETRY",
});
```

## Errores de Trusted Source

### Sobrescritura de Valor Manual

**Síntomas:**
- Un valor corregido por el usuario fue reemplazado
- El usuario reporta que "sus cambios se perdieron"

**Causa:** Un proceso batch (ingesta, sync) sobrescribió un valor `manual` con un valor `ai` o `cej`.

**Diagnóstico:**

```sql
-- Ver historial de cambios en el campo
SELECT 
  id,
  expediente,
  risk_level->>'cej' as cej_value,
  risk_level->>'ai' as ai_value,
  risk_level->>'manual' as manual_value,
  risk_level->'updatedAt'->>'manual' as manual_updated_at,
  "updatedAt"
FROM "Case"
WHERE id = 'case_xyz';
```

**Prevención:** Siempre verificar antes de sobrescribir:

```typescript
// En el servicio de ingesta
async function updateCaseFromCEJ(caseId: string, cejData: CEJData) {
  const existing = await caseRepo.findById(tenantDb, caseId);

  const updateData: Partial<CaseData> = {};

  // Solo actualizar campos CEJ si no hay valor manual
  for (const field of SOURCED_FIELDS) {
    const currentValue = existing[field] as SourcedValue;

    if (currentValue.manual === null) {
      updateData[field] = {
        ...currentValue,
        cej: cejData[field],
        updatedAt: {
          ...currentValue.updatedAt,
          cej: new Date().toISOString(),
        },
      };
    } else {
      console.log(`Skipping ${field} - manual value exists`);
    }
  }

  return caseRepo.update(tenantDb, caseId, updateData);
}
```

## Tabla de Referencia Rápida

| Error | Código | Causa Común | Solución |
|-------|--------|-------------|----------|
| `COMPANY_NOT_READY` | 422 | DB provisionando | Polling hasta `ready` |
| `TOOL_NOT_ALLOWED` | - | Perfil incorrecto | Cambiar `assistant_name` |
| `MISSING_AUTH_HEADERS` | 401 | Llamada directa sin Kong | Usar `/internal/...` |
| `ORGANIZATION_MISMATCH` | 403 | Token de otra org | Cambiar organización |
| `INGEST_RUN_FAILED` | - | Pipeline falló | Reintentar ingesta |
| Connection Timeout | - | Neon cold start | Retry con backoff |

## Próximos Pasos

<CardGroup cols={2}>
  <Card
    title="Mejores Prácticas"
    icon="lightbulb"
    href="/es/guias/mejores-practicas"
  >
    Evita estos errores desde el principio.
  </Card>
  <Card
    title="Debugging Ingesta"
    icon="bug"
    href="/es/guias/debugging-ingesta"
  >
    Troubleshooting del pipeline de datos.
  </Card>
  <Card
    title="API Reference"
    icon="code"
    href="/es/api-reference/errores"
  >
    Códigos de error de la API.
  </Card>
</CardGroup>
