---
title: Mejores Prácticas
description: Guía específica para desarrolladores de Clamo - evita los errores comunes
---

# Mejores Prácticas para Desarrolladores

Esta guía documenta las prácticas específicas de Clamo basadas en su arquitectura: **RRS**, **Unified AI**, **Multi-tenant estricto** y **Trusted Sources**. Sigue estas reglas para evitar los errores más comunes.

## Backend: Zero Trust en Base de Datos

<Warning>
**Regla Fundamental:** Nunca asumas que estás conectado a la base de datos correcta.
</Warning>

### Siempre usa `getTenantClient(ctx)`

```typescript
// ❌ INCORRECTO: Instanciar PrismaClient manualmente
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient({
  datasources: {
    db: { url: process.env.DATABASE_URL }, // ← ¿De qué tenant?
  },
});

const cases = await prisma.case.findMany(); // ← Datos de quién?
```

```typescript
// ✅ CORRECTO: Usar el cliente del contexto
async function handler(c: Context) {
  const tenantDb = c.get("tenantDb"); // ← Resuelto por middleware
  
  const cases = await tenantDb.case.findMany();
  // ✅ Siempre del tenant correcto
}
```

### Nunca construyas connection strings

```typescript
// ❌ INCORRECTO: Concatenar strings
const connectionString = `postgresql://${user}:${pass}@${host}/${dbName}`;
const prisma = new PrismaClient({ datasources: { db: { url: connectionString } } });
```

```typescript
// ✅ CORRECTO: Usar el SDK de Tenant
import { getTenantClient } from "@getclamo/database";

const tenantDb = await getTenantClient({
  companyId: company.id,
  connectionString, // ← Viene del Tenant SDK, encriptado en Vault
});
```

**Por qué:** Evita el error catastrófico de escribir datos del Cliente A en la base de datos del Cliente B.

## Data: Respeto a la Jerarquía de Fuentes (Trusted Source)

<Warning>
**Regla Fundamental:** El dato no es un string plano. Tiene origen y jerarquía.
</Warning>

### Verifica el origen antes de sobrescribir

```typescript
// ❌ INCORRECTO: Sobrescribir sin verificar
async function updateCaseFromAI(caseId: string, aiData: AIAnalysis) {
  await tenantDb.case.update({
    where: { id: caseId },
    data: {
      riskLevel: aiData.riskLevel, // ← ¿Y si el humano ya lo corrigió?
    },
  });
}
```

```typescript
// ✅ CORRECTO: Verificar jerarquía de fuentes
async function updateCaseFromAI(caseId: string, aiData: AIAnalysis) {
  const existingCase = await tenantDb.case.findUnique({
    where: { id: caseId },
  });

  const currentRiskLevel = existingCase.riskLevel as SourcedValue;

  // Si hay valor manual, NO sobrescribir con AI
  if (currentRiskLevel.manual !== null) {
    console.log("Skipping AI update - manual value exists");
    return existingCase;
  }

  // Solo actualizar el campo AI, preservar manual
  await tenantDb.case.update({
    where: { id: caseId },
    data: {
      riskLevel: {
        ...currentRiskLevel,
        ai: aiData.riskLevel,
        updatedAt: {
          ...currentRiskLevel.updatedAt,
          ai: new Date().toISOString(),
        },
      },
    },
  });
}
```

### Jerarquía de prioridad

```typescript
// utils/trusted-source.ts
type Source = "cej" | "ai" | "manual";

const SOURCE_PRIORITY: Record<Source, number> = {
  cej: 1,    // Más bajo - dato crudo del scraper
  ai: 2,     // Medio - normalizado por LLM
  manual: 3, // Más alto - corregido por humano
};

export function canOverwrite(
  current: SourcedValue,
  newSource: Source
): boolean {
  const currentSource = current.manual ? "manual" 
    : current.ai ? "ai" 
    : "cej";

  // Solo puede sobrescribir si tiene igual o mayor prioridad
  return SOURCE_PRIORITY[newSource] >= SOURCE_PRIORITY[currentSource];
}

export function resolveValue<T>(sourced: SourcedValue<T>): T | null {
  // Manual > AI > CEJ
  return sourced.manual ?? sourced.ai ?? sourced.cej ?? null;
}
```

## Código: Patrón RRS (Repository-Route-Service)

<Warning>
**Regla Fundamental:** Cada capa tiene una responsabilidad única. No las mezcles.
</Warning>

### Route: Solo validación y respuesta

```typescript
// ✅ CORRECTO
app.patch("/:id", zValidator("json", UpdateSchema), async (c) => {
  const id = c.req.param("id");
  const data = c.req.valid("json");
  const tenantDb = c.get("tenantDb");

  const result = await caseService.updateCase(tenantDb, id, data);

  return c.json(result);
});
```

```typescript
// ❌ INCORRECTO: Lógica de negocio en Route
app.patch("/:id", async (c) => {
  const id = c.req.param("id");
  const tenantDb = c.get("tenantDb");

  // ❌ Query de Prisma en el controlador
  const existing = await tenantDb.case.findUnique({ where: { id } });

  // ❌ Lógica de negocio en el controlador
  if (existing.status === "ARCHIVED") {
    return c.json({ error: "Cannot update" }, 400);
  }

  // ❌ Más queries en el controlador
  const updated = await tenantDb.case.update({ where: { id }, data });

  return c.json(updated);
});
```

### Service: Lógica de negocio

```typescript
// ✅ CORRECTO: Toda la lógica aquí
class CaseService {
  async updateCase(tenantDb: PrismaClient, id: string, data: UpdateInput) {
    const existing = await this.caseRepo.findById(tenantDb, id);

    if (!existing) {
      throw new NotFoundError("Case not found");
    }

    if (existing.status === "ARCHIVED") {
      throw new BusinessError("Cannot update archived case");
    }

    // Lógica de Trusted Source
    const updateData = this.prepareUpdate(existing, data);

    return this.caseRepo.update(tenantDb, id, updateData);
  }
}
```

### Repository: Solo acceso a datos

```typescript
// ✅ CORRECTO: Solo Prisma aquí
class CaseRepository {
  async findById(db: PrismaClient, id: string) {
    return db.case.findUnique({ where: { id } });
  }

  async update(db: PrismaClient, id: string, data: UpdateData) {
    return db.case.update({ where: { id }, data });
  }
}
```

## AI: Contexto antes que Pregunta

<Warning>
**Regla Fundamental:** Luna es ciega sin contexto. Siempre inyecta el estado necesario.
</Warning>

### Siempre pasa el `assistant_name` correcto

```typescript
// ❌ INCORRECTO: No especificar perfil
const response = await fetch(`${LANGGRAPH_URL}/runs`, {
  method: "POST",
  body: JSON.stringify({
    input: { messages: [{ role: "user", content: "Dame el resumen del caso" }] },
    // ← ¿Javi? ¿Clamy? ¿Luna?
  }),
});
```

```typescript
// ✅ CORRECTO: Especificar perfil y contexto
const response = await fetch(`${LANGGRAPH_URL}/runs`, {
  method: "POST",
  body: JSON.stringify({
    assistant_id: "luna",
    input: {
      messages: [{ role: "user", content: "Dame el resumen del caso" }],
    },
    config: {
      configurable: {
        assistant_name: "javi",  // ← Perfil específico
        case_id: caseId,         // ← Contexto del caso
        company_id: companyId,   // ← Contexto del tenant
      },
    },
  }),
});
```

### Inyecta IDs, no esperes que el LLM adivine

```typescript
// ❌ INCORRECTO: Esperar que el LLM extraiga del historial
const messages = [
  { role: "user", content: "Hablemos del caso 00001-2024-..." },
  { role: "assistant", content: "Claro, ese caso tiene..." },
  { role: "user", content: "¿Cuál es el riesgo?" }, // ← ¿De qué caso?
];
```

```typescript
// ✅ CORRECTO: Inyectar en el estado
const response = await langgraph.invoke({
  messages: [{ role: "user", content: "¿Cuál es el riesgo?" }],
  config: {
    configurable: {
      case_id: "case_abc123", // ← Explícito, no ambiguo
    },
  },
});
```

## Multi-Tenancy: Aislamiento Estricto

### Nunca confíes en el URL para usuarios autenticados

```typescript
// ❌ INCORRECTO: Usar companyId del URL
app.get("/companies/:companyId/cases", async (c) => {
  const companyId = c.req.param("companyId"); // ← ¿Y si lo manipulan?
  const tenantDb = await getTenantClient({ companyId });
  // ...
});
```

```typescript
// ✅ CORRECTO: Usar orgId del token (via middleware)
app.get("/v1/cases", async (c) => {
  const tenantDb = c.get("tenantDb"); // ← Resuelto desde x-workos-org-id
  // El middleware ya validó y resolvió el tenant correcto
});
```

### Endpoints internos: Sí usa el URL

```typescript
// ✅ CORRECTO para endpoints /internal/...
app.get("/internal/v1/companies/:companyId/cases", async (c) => {
  const companyId = c.req.param("companyId");
  // OK porque solo servicios internos pueden llamar aquí
  const tenantDb = await getTenantClient({ companyId, connectionString });
});
```

## Comunicación entre Servicios

### Siempre usa SDKs, nunca queries directas

```typescript
// ❌ INCORRECTO: Query directa a otra DB
// Desde clamo-cases intentando leer datos de clamo-tenant
const company = await controlDb.company.findUnique({
  where: { id: companyId },
});
```

```typescript
// ✅ CORRECTO: Usar el SDK
import Tenant from "@getclamo/tenant";

const tenant = new Tenant({ baseURL: env.TENANT_SERVICE_URL });
const company = await tenant.internal.companies.get(companyId);
```

### Usa endpoints internos para servicio-a-servicio

```typescript
// ❌ INCORRECTO: Llamar endpoint público desde backend
const response = await fetch(`${CASES_URL}/v1/cases/${caseId}`, {
  headers: { Authorization: `Bearer ${???}` }, // ← ¿Qué token?
});
```

```typescript
// ✅ CORRECTO: Usar endpoint interno
const response = await fetch(
  `${CASES_URL}/internal/v1/companies/${companyId}/cases/${caseId}`
);
// Sin auth - la red interna es confiable
```

## Checklist para Pull Requests

Antes de enviar un PR, verifica:

<Steps>
  <Step title="Patrón RRS">
    - [ ] Routes solo validan con Zod y responden JSON
    - [ ] Services contienen toda la lógica de negocio
    - [ ] Repositories son los únicos que importan `@getclamo/database`
  </Step>
  
  <Step title="Multi-Tenancy">
    - [ ] No hay `new PrismaClient()` manual
    - [ ] Uso `c.get("tenantDb")` del contexto
    - [ ] No confío en `companyId` del URL para usuarios autenticados
  </Step>
  
  <Step title="Trusted Source">
    - [ ] Verifico el origen antes de sobrescribir campos SourcedValue
    - [ ] No sobrescribo `manual` con `ai` o `cej` en procesos batch
    - [ ] Uso `resolveValue()` para obtener el valor final
  </Step>
  
  <Step title="AI/Luna">
    - [ ] Paso `assistant_name` en todas las invocaciones
    - [ ] Inyecto `case_id` y `company_id` en el config
    - [ ] No espero que el LLM adivine contexto del historial
  </Step>
  
  <Step title="Comunicación">
    - [ ] Uso SDKs para llamadas entre servicios
    - [ ] Uso `/internal/v1/...` para servicio-a-servicio
    - [ ] No hago queries directas a DBs de otros dominios
  </Step>
</Steps>

## Próximos Pasos

<CardGroup cols={2}>
  <Card
    title="Entidades"
    icon="database"
    href="/es/entidades/index"
  >
    Referencia completa de entidades.
  </Card>
  <Card
    title="Errores"
    icon="triangle-exclamation"
    href="/es/guias/errores"
  >
    Troubleshooting de errores específicos de Clamo.
  </Card>
</CardGroup>
